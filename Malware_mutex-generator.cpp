//copyright @Intelliroot
#pragma once
#define _CRT_SECURE_NO_WARNINGS
#include <windows.h>
#include <wincrypt.h>
#include <iostream>
#include <vector>
#include <string>
#include <fstream>
#include <sstream>

#pragma comment(lib, "Crypt32.lib")
#pragma comment(lib, "Advapi32.lib")

std::wstring stringToWString(const std::string& str) {
    int size_needed = MultiByteToWideChar(CP_UTF8, 0, &str[0], (int)str.size(), NULL, 0);
    std::wstring wstrTo(size_needed, 0);
    MultiByteToWideChar(CP_UTF8, 0, &str[0], (int)str.size(), &wstrTo[0], size_needed);
    return wstrTo;
}

// Function to read mutex names from a file, create mutexes, and print their names
void createMutexesFromFile(const std::string& filename) {
    std::ifstream file(filename);
    if (!file.is_open()) {
        std::cerr << "Failed to open file: " << filename << std::endl;
        return;
    }

    std::string line;
    while (std::getline(file, line)) {
        std::size_t commentPos = line.find("//");
        std::string mutexName = line.substr(0, commentPos);

        // Trim any leading or trailing whitespace from mutexName
        mutexName.erase(0, mutexName.find_first_not_of(" \t"));
        mutexName.erase(mutexName.find_last_not_of(" \t") + 1);

        if (!mutexName.empty()) {
            std::wstring wMutexName = stringToWString(mutexName);
            std::wcout << L"Read line: " << wMutexName << std::endl; // Print the line
            HANDLE hMutex = CreateMutex(NULL, FALSE, wMutexName.c_str());
            if (hMutex) {
                std::wcout << L"Created mutex: " << wMutexName << std::endl;
              //  CloseHandle(hMutex);
            }
            else {
                std::cerr << "Failed to create mutex: " << GetLastError() << std::endl;
            }
        }
    }
    file.close();
}

void LockbitMutex_Md4Hash() {
    // Retrieve the Machine GUID
    HKEY hKey;
    if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Cryptography", 0, KEY_READ | KEY_WOW64_64KEY, &hKey) != ERROR_SUCCESS) {
        std::cerr << "Failed to open registry key" << std::endl;
        return;
    }

    char guid[256];
    DWORD guidSize = sizeof(guid);
    DWORD type;
    if (RegQueryValueExA(hKey, "MachineGuid", nullptr, &type, reinterpret_cast<BYTE*>(guid), &guidSize) != ERROR_SUCCESS) {
        std::cerr << "Failed to query registry value" << std::endl;
        RegCloseKey(hKey);
        return;
    }
    RegCloseKey(hKey);
    std::string machineGuid(guid, guidSize - 1);

    std::cout << "Machine GUID: " << machineGuid << std::endl;

    // Compute the MD4 hash of the Machine GUID
    HCRYPTPROV hProv = 0;
    HCRYPTHASH hHash = 0;
    std::vector<BYTE> hashValue(16); // MD4 produces a 128-bit hash (16 bytes)

    if (!CryptAcquireContextA(&hProv, nullptr, nullptr, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
        std::cerr << "CryptAcquireContext failed with error: " << GetLastError() << std::endl;
        return;
    }
    if (!CryptCreateHash(hProv, CALG_MD4, 0, 0, &hHash)) {
        std::cerr << "CryptCreateHash failed with error: " << GetLastError() << std::endl;
        CryptReleaseContext(hProv, 0);
        return;
    }
    if (!CryptHashData(hHash, reinterpret_cast<const BYTE*>(machineGuid.c_str()), machineGuid.size(), 0)) {
        std::cerr << "CryptHashData failed with error: " << GetLastError() << std::endl;
        CryptDestroyHash(hHash);
        CryptReleaseContext(hProv, 0);
        return;
    }

    DWORD hashSize = hashValue.size();
    if (!CryptGetHashParam(hHash, HP_HASHVAL, hashValue.data(), &hashSize, 0)) {
        std::cerr << "CryptGetHashParam failed with error: " << GetLastError() << std::endl;
        CryptDestroyHash(hHash);
        CryptReleaseContext(hProv, 0);
        return;
    }
    CryptDestroyHash(hHash);
    CryptReleaseContext(hProv, 0);

    // Convert the hash to a string
    std::string hashStr;
    char buffer[3];
    for (BYTE b : hashValue) {
        sprintf(buffer, "%02x", b);
        hashStr += buffer;
    }

    std::cout << "MD4 Hash: " << hashStr << std::endl;

    // Create the mutex with the hash string
    std::string globalHashStr = "Global\\" + hashStr;
    HANDLE hMutex = CreateMutexA(nullptr, FALSE, globalHashStr.c_str());

    if (hMutex == nullptr) {
        std::cerr << "CreateMutex failed with error: " << GetLastError() << std::endl;
    }
    else {
        std::cout << "Mutex Name: " << globalHashStr << std::endl;
        if (GetLastError() == ERROR_ALREADY_EXISTS) {
            std::cerr << "Mutex already exists." << std::endl;
        }
        else {
            std::cout << "Mutex created successfully." << std::endl;
        }
       // CloseHandle(hMutex);
    }
}

int main() {
    LockbitMutex_Md4Hash();
    createMutexesFromFile("mutex_names.txt");

    while (1);
    return 0;
}
